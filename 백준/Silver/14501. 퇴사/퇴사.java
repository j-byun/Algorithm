import java.util.Scanner;

/**
 * @author jihye.byun
 * BOJ 14501 퇴사 실버3 DP
 * 
 * 문제
 * N+1일째 되는 날 퇴사 하기 위해 N일 동안 최대 수익을 내자.
 * 각 상담은 상담에 걸리는 기간 T와 상담비용 P로 이루어져 있다.
 * 하루에 하나의 상담만 진행할 수 있다.
 * 
 * 조건
 * N (1 ≤ N ≤ 15)
 * 1 ≤ Ti ≤ 5
 * 1 ≤ Pi ≤ 1,000
 * 
 * 풀이
 * 1. dp 배열을 만들어서 배열의 각 칸에 해당 인덱스 날짜에 벌 수 있는 최대 금액을 저장하자.
 * 2. 0~N+1번까지의 인덱스를 사용하자.
 * 2-1. N일에 시작한 하루짜리 일은 N+1일에 끝나서 N+1일에 정산받을 수 있기 때문에
 * 3. 만약 1일에 시작한 일의 T가 3, P가 10이라면,
 * 3-1. dp[1 + 3] 에 10을 저장하자.
 * 3-2. 일을 끝내야만 정산을 받을 수 있기 때문에
 * 4. i번째 날을 기준으로 생각해보자. (점화식 만들기)
 * 4-1. dp[i] : 오늘까지 끝난 일들로 번 최대 수익
 * 4-2. dp[i] + p[i] : 오늘까지 번 최대 수익 + 오늘부터 시작해서 t[i]일 후 끝날 일로 벌 수 있는 수익 
 * 4-3. 4-2의 값을 i일 부터 t[i]일 후인 dp[i + t[i]]에 저장해야 하는데,
 * 4-4. 만약 dp[i + t[i]] 칸에 값이 들어있다면, 이미 i일보다 이전에 시작한 일로 벌 수 있는 수익이 저장되어 있는 것이다.
 * 4-5. 두 일은 기간이 겹쳐서 동시에 진행할 수 없으니, 둘 중 큰 값만 살려서 dp[i + t[i]]에 저장하자.
 * 4-6. dp[i + t[i]] = Math.MAX(dp[i + t[i], dp[i] + p[i]);
 * 5. t[i]일 후의 계산이 끝났다면, 오늘까지 번 최대 수익을 내일로 업어가야 하는데,
 * 5-1. 이 때에도 마찬가지로 dp[i + 1]에 이미 값이 있다면, 오늘보다 이전에 시작한 일로 벌 수 있는 수익이 저장되어 있는 것이다.
 * 5-2. 두 일은 기간이 겹쳐서 동시에 진행할 수 없으니, 둘 중 큰 값만 살려서 dp[i + 1]에 저장하자.
 * 5-3. dp[i + 1] = Math.MAX(dp[i], dp[i + 1]);
 * 6. 1일~N일까지의 경우를 모두 확인한 후, dp[N + 1]을 출력하자.
 */

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int days = sc.nextInt(); // 일 할 날짜 입력받기
		int[] time = new int[days + 2]; // i일 부터 시작할 일에 소요되는 날짜
		int[] pay = new int[days + 2]; // i일 부터 시작할 일로 벌 수 있는 수익
		int[] dp = new int[days + 2]; // i일에 벌 수 있는 최대 수익을 저장할 배열
		
		// 각 상담들에 걸리는 기간과 수익 정보를 입력받자
		for (int idx = 1; idx <= days; idx++) {
			time[idx] = sc.nextInt();
			pay[idx] = sc.nextInt();
		}
		
		// 주석에 설명해놓은 점화식을 반복문으로 구현하자
		for (int idx = 1; idx <= days; idx++) {
			// N+1일까지 끝날 수 있는 상담만 고려하자
			// 기간 안에 끝낼 수 없으면 고려할 가치도 없음! 퇴사가 우선이다
			if (idx + time[idx] <= days + 1) {
				dp[idx + time[idx]] = Math.max(dp[idx + time[idx]], dp[idx] + pay[idx]);
			}
			// 오늘까지 번 최대 수익 내일로 업어가기
			dp[idx + 1] = Math.max(dp[idx + 1], dp[idx]);
		}
		
		// N일에 시작해서 기간이 1인 일은 N+1일에 끝나서 그 날 수익이 정산되므로,
		// N+1일에 벌 수 있는 최대 수익을 출력하자
		System.out.println(dp[days + 1]);
	}
	
}
